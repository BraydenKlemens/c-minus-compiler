A JFlex + Cup implementation for the C- programming language written by Boris Skurikhin & Brayden Klemens

-- This implementation references/uses starter code provided by Fei Song --

========
BUILDING
========

    To build the parser, type "make" in the current directory, which will 
    generate an executable program called "Main".

========
RUNNING!
========

    "java -cp /usr/share/java/cup.jar:. Main test_files/1.cm -a"

Where "test_files/1.cm" is a working code sample we provided.
The syntax tree will be dumped into an ".abs" file with the name (in the same directory as the source file).
Any error messages will be sent to stderr. 

  To rebuild the parser, type "make clean" and type "make" again.

Also note that all the abstract syntax tree structures are defined under
the directory "absyn" and the methods for showing a syntax tree is implemented
by the visitor pattern in "ShowTreeVisitor.java".  Since some java files are 
generated automatically, they may contain variables that are not used, which 
are safe to ignore in the compilation process.

==========
THE FIVE TEST FILES
==========

Can be found in the "test_files" folder and labeled
1.cm, 2.cm, 3.cm, 4.cm and 5.cm respectively. The first file is a perfectly
working file, while the rest have various errors!

==========
LIMITATIONS
==========

Our compiler does not have error recovery for top level declarations such as an invalid function declaration, 
or statement declarations. For example if we were to define a function with an invalid type such as ‘String function(param, param)’
our compiler does not have error recovery for this scenario. Thus, the compiler will produce a syntax error, and will fail to 
continue the parsing for all top level declarations.

===========
ASSUMPTIONS
===========

1. For the sake of the test files, we assume that all of the test files (1-5.cm) should end with the .cm extension.

2. We assume that only 1 .cm source code file will be passed into the compilation, and its name/path does not start with the symbol “-”

3. As per the project outline, our program requires -a flag to run the parser and output the syntax tree to a file. If the “-a” flag is not present, the execution of the program will halt right away. 

4. Assume that the errors should only be written to stderr, error messages will not appear in the syntax tree file.

5. Any error recovery in the syntax tree is displayed with an ‘ERROR’ identifier.
